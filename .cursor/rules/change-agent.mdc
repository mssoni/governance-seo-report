---
description: Change Agent orchestration process — activates when the user requests a change, feature, fix, or enhancement to the application
alwaysApply: true
---

# Change Agent Process

When the user describes a change request (new feature, bug fix, enhancement, refactor), follow the 8-step lifecycle in `CHANGE_PROCESS.md`.

## Trigger Detection

Activate this process when the user's message implies a change to the codebase:
- "Add ...", "Fix ...", "Change ...", "Update ...", "Remove ...", "Refactor ..."
- "I want to ...", "Can you ...", "We need ..."
- Bug reports, feature requests, UI tweaks, API changes

## Workflow

### DECOMPOSE (6 sub-steps)
1. Read `CHANGE_PROCESS.md` for the full lifecycle
2. Read `CHANGE_MANIFEST.json` for current contract version, commit SHAs, and compatibility matrix
3. Read `backend/ARCHITECTURE.md` and `frontend/ARCHITECTURE.md` for current state
4. Read `backend/CONTRACTS.md` if the change may affect API schemas
5. **Pre-flight invariant check:** Does this violate a V1 non-goal or core constraint? (See §3.1) If yes → `NEEDS_PRODUCT_DECISION` before stories
6. **Outcome framing:** What metric does this affect? Is the request a means or an end? Is there a cheaper way? (See §3.2) Escalate only if wrong metric or high complexity / low impact
7. Decompose into stories using the Story Template (§3.3): risk level, mandatory out-of-scope, optional "unlocks later"
8. **Confidence signal:** Rate HIGH/MEDIUM/LOW — if LOW, bias toward smaller stories
9. Run `./scripts/new_change_id.sh` to allocate the next Change ID (CHG-NNN)
10. Log the change in `CHANGE_LOG.md` as Status: IN_PROGRESS (with Labels if applicable)

### DEVELOP + REVIEW + MERGE
11. Create feature branches: `change/CHG-NNN-short-description` (uppercase CHG)
12. Spawn dev agents in parallel using the Task tool (backend + frontend, or just one)
13. After dev agents complete, spawn a review agent
14. Review Agent reports APPROVED/REJECTED (does NOT merge)
15. If approved: orchestrator runs merge gate:
    a. Verify `make check` green in both repos
    b. Verify `make dod` green in both repos
    c. Verify CHANGE_LOG.md entry is complete
    d. Verify no unresolved NEEDS_PRODUCT_DECISION labels
16. Atomic cross-repo merge (always `--no-ff`, never squash):
    a. Append STARTED entry to `MERGE_TRANSACTIONS.md`
    b. Merge backend branch to main: `git merge --no-ff change/CHG-NNN-...` (if changed)
    c. Merge frontend branch to main: `git merge --no-ff change/CHG-NNN-...` (if changed)
    d. If (c) fails → revert (b), log ROLLED_BACK in `MERGE_TRANSACTIONS.md`, mark PARTIAL_MERGE_BLOCKED
    e. Only after both succeed: update `CHANGE_MANIFEST.json` with both merge commit SHAs
    f. Log COMPLETED in `MERGE_TRANSACTIONS.md`
17. Update `CHANGE_LOG.md` status to COMPLETE
18. Report summary to user

## Rules

- Never ask the user for permission to proceed — execute autonomously (unless NEEDS_PRODUCT_DECISION)
- Always run pre-flight invariant check before writing stories (§3.1)
- Always run outcome framing internally — escalate only if wrong metric or high complexity/low impact
- Always assign Risk Level (LOW/MEDIUM/HIGH) and at least 1 Out of Scope item per story
- Always output Confidence Signal (HIGH/MEDIUM/LOW) before spawning agents
- Always use TDD (test first, then implement)
- Always run `make check` + `make dod` before and after changes
- Always update documentation (ARCHITECTURE.md, PROGRESS.md)
- Always run `make dod` + `DEFINITION_OF_DONE.md` checklist before merge
- Use Contract-First if any API schema changes — bump contract_version
- Follow naming: `CHG-NNN` uppercase everywhere, branch `change/CHG-NNN-desc`
- IO boundary: only designated fetch modules may do HTTP
- Review Agent approves but does NOT merge — orchestrator handles merge gate
- When ambiguity arises, apply Global Default Behavior Rules (§3.6): prefer additive, readable, safe, explicit, simple, contained
- No effort estimates, time estimates, or story points — this process is outcome-driven
